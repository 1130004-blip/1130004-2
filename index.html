<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多人3D射擊遊戲</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .crosshair-line {
            background-color: rgba(255, 255, 255, 0.8);
            position: absolute;
            border-radius: 1px;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            font-size: 16px;
            width: 240px;
        }
        #respawn-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            font-size: 24px;
        }
        .hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid red;
            transform: translate(-50%, -50%) rotate(45deg);
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }
        #controls-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none; /* So it doesn't interfere with game clicks */
        }
        #controls-info kbd {
            background-color: rgba(0, 0, 0, 0.4);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-family: monospace;
            display: inline-block;
            width: 120px;
            text-align: center;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <p>您的 ID: <span id="player-id"></span></p>
        <p>生命值: <span id="health">100</span> | 分數: <span id="score">0</span></p>
        <p>武器: <span id="current-weapon">手槍</span></p>
        <p>彈藥: <span id="ammo-status">-- / --</span></p>
        <p class="mt-1">在畫面上點擊以鎖定滑鼠</p>
        <div class="mt-2">
            <label for="sensitivity" class="block">滑鼠靈敏度: <span id="sensitivity-value">1.0</span></label>
            <input type="range" id="sensitivity" min="0.1" max="2" value="1" step="0.1" class="w-full">
        </div>
    </div>
    <div id="crosshair">
        <div class="crosshair-line" style="width: 2px; height: 20px;"></div>
        <div class="crosshair-line" style="width: 20px; height: 2px;"></div>
    </div>
    <div id="hit-marker" class="hit-marker"></div>

    <div id="controls-info">
        <h3 class="text-md font-bold mb-2">控制說明</h3>
        <ul class="text-sm space-y-1">
            <li><kbd>WASD / 方向鍵</kbd> 移動</li>
            <li><kbd>空白鍵</kbd> 跳躍</li>
            <li><kbd>滑鼠移動</kbd> 調整視角</li>
            <li><kbd>滑鼠左鍵</kbd> 射擊</li>
            <li><kbd>滑鼠滾輪</kbd> 切換武器</li>
            <li><kbd>1, 2, 3</kbd> 切換武器</li>
            <li><kbd>R</kbd> 裝填</li>
        </ul>
    </div>

    <div id="respawn-overlay">
        <h1 class="text-4xl font-bold mb-4">您已被擊敗！</h1>
        <p class="mb-2">擊敗您的是: <span id="killer-id"></span></p>
        <p id="respawn-timer" class="text-2xl"></p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        
        // --- Firebase 設定 ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, deleteDoc, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        // --- 全域變數 ---
        let camera, scene, renderer, controls;
        let viewModelScene, viewModelCamera; // 新增：用於武器模型的獨立場景和攝影機
        let db, auth;
        let userId;

        const players = {}; 
        const playerMeshes = {}; 
        const bullets = []; 
        const collidableObjects = []; 
        const decals = []; 
        const maxDecals = 100;

        let weaponContainer;
        const weaponModels = {};

        const moveSpeed = 5.0;
        const jumpHeight = 8.0;

        const keysPressed = {};
        const playerVelocity = new THREE.Vector3();
        let onGround = false;
        let isShooting = false;
        let lastShotTime = 0;
        let isReloading = false;

        const appId = typeof __app_id !== 'undefined' ? __app_id : '3d-shooter-default';
        
        const WEAPONS = [
            { name: '手槍', damage: 25, fireRate: 500, bulletSpeed: 150, ammo: 12, reloadTime: 1500 },
            { name: '衝鋒槍', damage: 15, fireRate: 100, bulletSpeed: 200, ammo: 30, reloadTime: 2200 },
            { name: '狙擊槍', damage: 75, fireRate: 1500, bulletSpeed: 500, ammo: 5, reloadTime: 3000 },
        ];

        // --- 初始化函式 ---
        async function init() {
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            let gameHasStarted = false;
            onAuthStateChanged(auth, user => {
                if (user && !gameHasStarted) {
                    gameHasStarted = true;
                    startGame(user);
                }
            });

            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase 認證失敗:", error);
                document.getElementById('ui-container').innerHTML = "<p>錯誤：無法連接到伺服器。請刷新頁面。</p>";
            }
        }
        
        function startGame(user) {
            userId = user.uid;
            document.getElementById('player-id').textContent = userId;

            const playerRef = doc(db, `artifacts/${appId}/public/data/players`, userId);
            onSnapshot(playerRef, handleLocalPlayerState);
            
            window.addEventListener('beforeunload', () => {
                if (userId) {
                    deleteDoc(doc(db, `artifacts/${appId}/public/data/players`, userId));
                }
            });
            
            setupScene();
            setupPlayer();
            setupWeaponModels();
            setupEventListeners();
            setupFirebaseListeners();
            
            animate();
        }

        // --- Three.js 場景設定 ---
        function setupScene() {
            // 主場景 (遊戲世界)
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, 100);

            // 武器模型場景
            viewModelScene = new THREE.Scene();

            // 主攝影機
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.6;

            // 武器模型專用攝影機
            viewModelCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.autoClear = false; // *** 錯誤修正：手動控制渲染器清除，為多層渲染做準備 ***
            document.body.appendChild(renderer.domElement);

            // 光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight.clone()); // 兩個場景都需要光源
            viewModelScene.add(ambientLight.clone());

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight.clone());
            viewModelScene.add(directionalLight.clone());

            // 地板
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            collidableObjects.push(ground);

            // 障礙物
            for (let i = 0; i < 20; i++) {
                const boxGeometry = new THREE.BoxGeometry(
                    Math.random() * 5 + 2,
                    Math.random() * 10 + 2,
                    Math.random() * 5 + 2
                );
                const boxMaterial = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                box.position.set(
                    (Math.random() - 0.5) * 150,
                    boxGeometry.parameters.height / 2,
                    (Math.random() - 0.5) * 150
                );
                box.castShadow = true;
                box.receiveShadow = true;
                scene.add(box);
                collidableObjects.push(box);
            }

            controls = new PointerLockControls(camera, renderer.domElement);
            renderer.domElement.addEventListener('click', () => {
                controls.lock();
            });
        }

        // --- 武器模型設定 ---
        function setupWeaponModels() {
            weaponContainer = new THREE.Object3D();
            viewModelScene.add(weaponContainer); // *** 錯誤修正：將武器模型加入獨立的場景 ***
            weaponContainer.position.set(0.25, -0.25, -0.5);
            weaponContainer.rotation.y = -Math.PI / 20;

            const createGunMaterial = (color) => new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.5,
            });

            const gunMaterial = createGunMaterial(0x333333);
            const darkGunMaterial = createGunMaterial(0x222222);
            const scopeMaterial = createGunMaterial(0x111111);

            // 手槍
            const pistolGroup = new THREE.Group();
            const pistolGrip = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.1), darkGunMaterial);
            pistolGrip.position.y = -0.1;
            const pistolSlide = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.4), gunMaterial);
            pistolSlide.position.set(0, 0.1, -0.1);
            pistolGroup.add(pistolGrip, pistolSlide);
            weaponModels['手槍'] = pistolGroup;
            weaponContainer.add(pistolGroup);
            
            // 衝鋒槍
            const smgGroup = new THREE.Group();
            const smgBody = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.6), gunMaterial);
            smgBody.position.y = 0.05;
            const smgGrip = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.1), darkGunMaterial);
            smgGrip.position.y = -0.1;
            const smgMag = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.25, 0.1), darkGunMaterial);
            smgMag.position.set(0, -0.05, -0.15);
            const smgBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.2, 16), darkGunMaterial);
            smgBarrel.position.set(0, 0.05, -0.4);
            smgBarrel.rotation.x = Math.PI / 2;
            smgGroup.add(smgBody, smgGrip, smgMag, smgBarrel);
            smgGroup.visible = false;
            weaponModels['衝鋒槍'] = smgGroup;
            weaponContainer.add(smgGroup);

            // 狙擊槍
            const sniperGroup = new THREE.Group();
            const sniperBody = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 1.2), gunMaterial);
            const sniperStock = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.4), darkGunMaterial);
            sniperStock.position.set(0, -0.05, 0.5);
            const sniperBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.8, 16), darkGunMaterial);
            sniperBarrel.position.set(0, 0, -0.8);
            sniperBarrel.rotation.x = Math.PI / 2;
            const sniperScope = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3, 16), scopeMaterial);
            sniperScope.position.y = 0.15;
            sniperScope.rotation.z = Math.PI / 2;
            sniperGroup.add(sniperBody, sniperStock, sniperBarrel, sniperScope);
            sniperGroup.visible = false;
            weaponModels['狙擊槍'] = sniperGroup;
            weaponContainer.add(sniperGroup);
        }
        
        // --- 玩家設定 ---
        function setupPlayer() {
            const initialWeapon = WEAPONS[0];
            players[userId] = {
                position: { x: (Math.random() - 0.5) * 50, y: 1.6, z: (Math.random() - 0.5) * 50 },
                rotation: { x: 0, y: 0, z: 0 },
                health: 100,
                score: 0,
                isDead: false,
                currentWeaponIndex: 0,
                currentAmmo: initialWeapon.ammo,
                lastUpdateTime: Date.now()
            };
            camera.position.set(players[userId].position.x, players[userId].position.y, players[userId].position.z);
            updateWeaponUI(0);
            updatePlayerOnFirestore();
        }

        // --- 事件監聽器 ---
        function setupEventListeners() {
            document.addEventListener('keydown', (event) => {
                keysPressed[event.code] = true;
                if (event.code === 'Digit1') switchWeapon(0);
                if (event.code === 'Digit2') switchWeapon(1);
                if (event.code === 'Digit3') switchWeapon(2);
                if (event.code === 'KeyR') startReload();
            });
            document.addEventListener('keyup', (event) => {
                keysPressed[event.code] = false;
            });
             renderer.domElement.addEventListener('mousedown', (event) => {
                if (controls.isLocked && event.button === 0) {
                    isShooting = true;
                }
            });
             renderer.domElement.addEventListener('mouseup', (event) => {
                if (event.button === 0) {
                    isShooting = false;
                }
            });
            window.addEventListener('resize', onWindowResize);

            document.addEventListener('wheel', (event) => {
                if (!controls.isLocked || !players[userId]) return;

                const currentWeaponIndex = players[userId].currentWeaponIndex;
                let newIndex = currentWeaponIndex;

                if (event.deltaY < 0) { // 滾輪向上
                    newIndex = (currentWeaponIndex - 1 + WEAPONS.length) % WEAPONS.length;
                } else if (event.deltaY > 0) { // 滾輪向下
                    newIndex = (currentWeaponIndex + 1) % WEAPONS.length;
                }

                if (newIndex !== currentWeaponIndex) {
                    switchWeapon(newIndex);
                }
            });

            const sensitivitySlider = document.getElementById('sensitivity');
            const sensitivityValue = document.getElementById('sensitivity-value');
            sensitivitySlider.addEventListener('input', (event) => {
                const newSensitivity = parseFloat(event.target.value);
                if (controls) {
                    controls.pointerSpeed = newSensitivity;
                }
                sensitivityValue.textContent = newSensitivity.toFixed(1);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // *** 錯誤修正：同步更新武器攝影機的長寬比 ***
            viewModelCamera.aspect = window.innerWidth / window.innerHeight;
            viewModelCamera.updateProjectionMatrix();
            
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Firebase 監聽器 ---
        function setupFirebaseListeners() {
            const playersRef = collection(db, `artifacts/${appId}/public/data/players`);
            onSnapshot(playersRef, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const id = change.doc.id;
                    const data = change.doc.data();

                    if (id === userId) return;

                    if (change.type === "added" || change.type === "modified") {
                        if (!playerMeshes[id]) {
                            const geometry = new THREE.CapsuleGeometry(0.5, 1);
                            const material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
                            const playerMesh = new THREE.Mesh(geometry, material);
                            playerMesh.castShadow = true;
                            playerMeshes[id] = playerMesh;
                            scene.add(playerMesh);
                        }
                        
                        playerMeshes[id].position.set(data.position.x, data.position.y - 0.8, data.position.z); 
                        playerMeshes[id].rotation.set(data.rotation.x, data.rotation.y, data.rotation.z);
                        
                        if (data.isDead && (!players[id] || !players[id].isDead)) {
                             handlePlayerDeathEffect(playerMeshes[id].position);
                        }
                        playerMeshes[id].visible = !data.isDead;

                    } else if (change.type === "removed") {
                        if (playerMeshes[id]) {
                            scene.remove(playerMeshes[id]);
                            delete playerMeshes[id];
                        }
                    }
                    players[id] = data;
                });
            });
        }
        
        // --- 核心遊戲邏輯 ---
        let lastUpdateTime = 0;
        const updateInterval = 1000 / 20;

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const delta = (now - (lastUpdateTime || now)) / 1000;
            
            if (controls.isLocked) {
                updatePlayerMovement(delta);
                 if (isShooting && players[userId] && !players[userId].isDead) {
                    tryShoot();
                }
            }
            
            updateBullets(delta);
            
            if (now - lastUpdateTime > updateInterval && userId && players[userId] && !players[userId].isDead) {
                updatePlayerOnFirestore();
                lastUpdateTime = now;
            }
            
            // *** 錯誤修正：實現雙攝影機分層渲染 ***
            // 1. 同步武器攝影機的視角
            viewModelCamera.quaternion.copy(camera.quaternion);

            // 2. 清除畫面
            renderer.clear();
            
            // 3. 渲染遊戲世界
            renderer.render(scene, camera);

            // 4. 清除深度緩衝區，讓武器永遠顯示在最前面
            renderer.clearDepth();

            // 5. 渲染武器模型
            renderer.render(viewModelScene, viewModelCamera);
        }

        function checkCollision() {
            const playerHeight = 1.6;
            const playerRadius = 0.4;
            const playerCollider = new THREE.Box3().setFromPoints([
                 new THREE.Vector3(camera.position.x - playerRadius, camera.position.y - playerHeight, camera.position.z - playerRadius),
                 new THREE.Vector3(camera.position.x + playerRadius, camera.position.y, camera.position.z + playerRadius),
            ]);

            for (const object of collidableObjects) {
                object.updateWorldMatrix(true, false);
                const objectCollider = new THREE.Box3().setFromObject(object);
                if (playerCollider.intersectsBox(objectCollider)) {
                    return true;
                }
            }
            return false;
        }

        function updatePlayerMovement(delta) {
             if (!players[userId] || players[userId].isDead) return;
            
            const originalPosition = camera.position.clone();

            // --- 重力與垂直碰撞 ---
            playerVelocity.y -= 9.8 * 2 * delta;
            camera.position.y += playerVelocity.y * delta;
            
            if (checkCollision()) {
                const isFalling = playerVelocity.y < 0;
                camera.position.y = originalPosition.y;
                playerVelocity.y = 0;
                if(isFalling) {
                    onGround = true;
                }
            } else {
                 onGround = false;
                 if (camera.position.y < 1.6) {
                    camera.position.y = 1.6;
                    playerVelocity.y = 0;
                    onGround = true;
                }
            }

            // --- 跳躍 ---
            if (keysPressed['Space'] && onGround) {
                playerVelocity.y = jumpHeight;
                onGround = false;
            }

            // --- 水平移動 ---
            const forwardSpeed = (keysPressed['KeyW'] || keysPressed['ArrowUp'] ? 1 : 0) - (keysPressed['KeyS'] || keysPressed['ArrowDown'] ? 1 : 0);
            const sideSpeed = (keysPressed['KeyD'] || keysPressed['ArrowRight'] ? 1 : 0) - (keysPressed['KeyA'] || keysPressed['ArrowLeft'] ? 1 : 0);
            
            const direction = new THREE.Vector3();
            controls.getDirection(direction);
            direction.y = 0;
            direction.normalize();

            const forwardVector = direction.clone().multiplyScalar(forwardSpeed * moveSpeed * delta);
            const sideVector = new THREE.Vector3();
            sideVector.crossVectors(camera.up, direction).multiplyScalar(-sideSpeed * moveSpeed * delta);
            
            const combinedMovement = forwardVector.add(sideVector);

            camera.position.x += combinedMovement.x;
            if (checkCollision()) {
                camera.position.x = originalPosition.x;
            }

            camera.position.z += combinedMovement.z;
            if (checkCollision()) {
                camera.position.z = originalPosition.z;
            }

            players[userId].position = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
            players[userId].rotation = { x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z };
        }
        
        function updatePlayerOnFirestore() {
            if (!userId || !players[userId]) return;
            players[userId].lastUpdateTime = Date.now();
            const playerRef = doc(db, `artifacts/${appId}/public/data/players`, userId);
            setDoc(playerRef, players[userId], { merge: true });
        }
        
        function tryShoot() {
            if (isReloading || players[userId].currentAmmo <= 0) return;

            const weaponIndex = players[userId]?.currentWeaponIndex || 0;
            const weapon = WEAPONS[weaponIndex];
            const now = Date.now();
            if (now - lastShotTime > weapon.fireRate) {
                shoot(weapon);
                lastShotTime = now;
                players[userId].currentAmmo--;
                updateAmmoUI();
            }
        }

        function shoot(weapon) {
            const raycaster = new THREE.Raycaster();
            const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            raycaster.set(camera.position, direction);

            const muzzleFlash = new THREE.PointLight(0xfff5a1, 10, 10);
            muzzleFlash.position.copy(camera.position).add(direction.clone().multiplyScalar(0.5));
            scene.add(muzzleFlash);
            setTimeout(() => scene.remove(muzzleFlash), 60);

            const bulletGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.6, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            bullet.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
            bullet.position.copy(camera.position).add(direction.clone().multiplyScalar(0.7));
            bullet.velocity = direction.clone().multiplyScalar(weapon.bulletSpeed);
            scene.add(bullet);
            bullets.push(bullet);

            const otherPlayerMeshes = Object.values(playerMeshes).filter(mesh => mesh.visible);
            const intersects = raycaster.intersectObjects(otherPlayerMeshes);

            if (intersects.length > 0) {
                const targetMesh = intersects[0].object;
                const targetId = Object.keys(playerMeshes).find(id => playerMeshes[id] === targetMesh);

                if (targetId && players[targetId] && !players[targetId].isDead) {
                    handleHit(targetId, weapon.damage);
                    showHitMarker();
                }
            }
            
            const envIntersects = raycaster.intersectObjects(collidableObjects);

            if (envIntersects.length > 0) {
                const intersect = envIntersects[0];

                const decalGeometry = new THREE.PlaneGeometry(0.2, 0.2);
                const decalMaterial = new THREE.MeshBasicMaterial({
                    color: 0x222222,
                    transparent: true,
                    opacity: 0.7,
                });
                const decal = new THREE.Mesh(decalGeometry, decalMaterial);

                decal.position.copy(intersect.point);
                decal.lookAt(intersect.point.clone().add(intersect.face.normal));
                decal.position.add(intersect.face.normal.clone().multiplyScalar(0.01));

                scene.add(decal);
                decals.push(decal);

                if (decals.length > maxDecals) {
                    const oldDecal = decals.shift();
                    scene.remove(oldDecal);
                }
            }
        }

        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.add(bullet.velocity.clone().multiplyScalar(delta));

                if (bullet.position.distanceTo(camera.position) > 200) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }
        
        function showHitMarker() {
            const hitMarker = document.getElementById('hit-marker');
            hitMarker.style.opacity = '1';
            setTimeout(() => {
                hitMarker.style.opacity = '0';
            }, 200);
        }

        async function handleHit(targetId, damage) {
            const targetPlayerRef = doc(db, `artifacts/${appId}/public/data/players`, targetId);
            try {
                await runTransaction(db, async (transaction) => {
                    const targetDoc = await transaction.get(targetPlayerRef);
                    if (!targetDoc.exists()) return;

                    const data = targetDoc.data();
                    if(data.isDead) return;

                    const newHealth = Math.max(0, data.health - damage);
                    transaction.update(targetPlayerRef, { health: newHealth });
                    
                    if (newHealth <= 0 && data.health > 0) {
                       transaction.update(targetPlayerRef, { isDead: true, killer: userId });
                       
                       const killerPlayerRef = doc(db, `artifacts/${appId}/public/data/players`, userId);
                       const killerDoc = await transaction.get(killerPlayerRef);
                       if(killerDoc.exists()){
                           const currentScore = killerDoc.data().score || 0;
                           transaction.update(killerPlayerRef, { score: currentScore + 1 });
                       }
                    }
                });
            } catch (e) {
                console.error("處理傷害時發生錯誤: ", e);
            }
        }

        function handleLocalPlayerState(snapshot) {
            const data = snapshot.data();
            if (!data) return;

            const isCurrentlyDead = players[userId]?.isDead || false;
            
            if (players[userId] && players[userId].currentWeaponIndex !== data.currentWeaponIndex) {
                 updateWeaponUI(data.currentWeaponIndex);
            }
            
             if (players[userId] && players[userId].currentAmmo !== data.currentAmmo) {
                updateAmmoUI();
            }

            players[userId] = data;

            document.getElementById('health').textContent = data.health;
            document.getElementById('score').textContent = data.score;

            if (data.isDead && !isCurrentlyDead) {
                playerDied(data.killer);
            }
        }

        function playerDied(killerId) {
            players[userId].isDead = true;
            isShooting = false;
            if (weaponContainer) weaponContainer.visible = false;
            controls.unlock();
            const overlay = document.getElementById('respawn-overlay');
            const timerEl = document.getElementById('respawn-timer');
            const killerEl = document.getElementById('killer-id');
            
            killerEl.textContent = killerId || "未知";
            overlay.style.display = 'flex';
            
            let countdown = 5;
            timerEl.textContent = `將在 ${countdown} 秒後重生...`;

            const interval = setInterval(() => {
                countdown--;
                timerEl.textContent = `將在 ${countdown} 秒後重生...`;
                if (countdown <= 0) {
                    clearInterval(interval);
                    respawn();
                }
            }, 1000);
        }

        function respawn() {
            const overlay = document.getElementById('respawn-overlay');
            overlay.style.display = 'none';
            
            if (weaponContainer) weaponContainer.visible = true;
            
            const weapon = WEAPONS[players[userId].currentWeaponIndex];
            players[userId].isDead = false;
            players[userId].health = 100;
            players[userId].currentAmmo = weapon.ammo;

            const newPosition = {
                x: (Math.random() - 0.5) * 50,
                y: 1.6,
                z: (Math.random() - 0.5) * 50
            };
            players[userId].position = newPosition;
            camera.position.set(newPosition.x, newPosition.y, newPosition.z);
            
            const weaponName = weapon.name;
            for (const name in weaponModels) {
                if (weaponModels[name]) {
                    weaponModels[name].visible = (name === weaponName);
                }
            }

            updatePlayerOnFirestore();
            updateAmmoUI();
            controls.lock();
        }
        
        function switchWeapon(index) {
            if (isReloading || !players[userId] || index < 0 || index >= WEAPONS.length) return;
            
            players[userId].currentWeaponIndex = index;
            const newWeapon = WEAPONS[index];
            players[userId].currentAmmo = newWeapon.ammo;
            
            updateWeaponUI(index);
            updatePlayerOnFirestore();

            const newWeaponName = newWeapon.name;
            for (const name in weaponModels) {
                if (weaponModels[name]) {
                    weaponModels[name].visible = (name === newWeaponName);
                }
            }
        }

        function startReload() {
            if (isReloading || !players[userId]) return;
            
            const weaponIndex = players[userId].currentWeaponIndex;
            const weapon = WEAPONS[weaponIndex];
            
            if (players[userId].currentAmmo === weapon.ammo) return;

            isReloading = true;
            document.getElementById('ammo-status').textContent = '裝填中...';

            setTimeout(() => {
                players[userId].currentAmmo = weapon.ammo;
                isReloading = false;
                updateAmmoUI();
                updatePlayerOnFirestore();
            }, weapon.reloadTime);
        }

        function updateWeaponUI(index) {
             if (index >= 0 && index < WEAPONS.length) {
                document.getElementById('current-weapon').textContent = WEAPONS[index].name;
                updateAmmoUI();
             }
        }
        
        function updateAmmoUI() {
            if (!players[userId]) return;
            if (isReloading) return;
            const weaponIndex = players[userId].currentWeaponIndex;
            const weapon = WEAPONS[weaponIndex];
            const ammoStatus = document.getElementById('ammo-status');
            ammoStatus.textContent = `${players[userId].currentAmmo} / ${weapon.ammo}`;
        }

        function handlePlayerDeathEffect(position) {
            const particleCount = 50;
            const particles = new THREE.BufferGeometry();
            const pMaterial = new THREE.PointsMaterial({
                color: 0xFF0000,
                size: 0.3,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            const pVerts = [];
            for (let i = 0; i < particleCount; i++) {
                pVerts.push(position.x, position.y, position.z);
            }
            particles.setAttribute('position', new THREE.Float32BufferAttribute(pVerts, 3));
            
            const particleSystem = new THREE.Points(particles, pMaterial);
            scene.add(particleSystem);

            let time = 0;
            const updateParticles = () => {
                time += 0.01;
                if(time > 1) {
                    scene.remove(particleSystem);
                    return;
                }
                const positions = particleSystem.geometry.attributes.position.array;
                for(let i=0; i<particleCount; i++){
                    positions[i*3 + 1] += (Math.random() - 0.5) * 0.5;
                    positions[i*3] += (Math.random() - 0.5) * 0.5;
                    positions[i*3 + 2] += (Math.random() - 0.5) * 0.5;
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
                pMaterial.opacity = 1.0 - time;
                requestAnimationFrame(updateParticles);
            }
            updateParticles();
        }
        
        // --- 啟動遊戲 ---
        init();

    </script>
</body>
</html>

